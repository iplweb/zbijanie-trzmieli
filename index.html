<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zbijanie Trzmieli</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            height: 100vh;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="10" y="0" width="12" height="20" fill="%23964B00" rx="2"/><rect x="8" y="18" width="16" height="14" fill="%23D3D3D3" rx="4"/><line x1="16" y1="20" x2="16" y2="30" stroke="%23666" stroke-width="0.5"/><line x1="12" y1="20" x2="12" y2="30" stroke="%23666" stroke-width="0.5"/><line x1="20" y1="20" x2="20" y2="30" stroke="%23666" stroke-width="0.5"/></svg>') 16 16, crosshair;
            user-select: none;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                /* Database grid pattern */
                linear-gradient(rgba(0, 255, 0, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.03) 1px, transparent 1px),
                /* Matrix-like vertical lines */
                linear-gradient(rgba(0, 255, 0, 0.02) 2px, transparent 10px),
                /* Dark base */
                linear-gradient(135deg, #0a0f0a 0%, #001a00 50%, #0a0f0a 100%);
            background-size: 50px 50px, 50px 50px, 10px 100%, 100% 100%;
            z-index: 0;
        }
        
        /* Database terminal effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 0, 0.03) 2px,
                    rgba(0, 255, 0, 0.03) 4px
                );
            animation: scan 8s linear infinite;
            z-index: 0;
            pointer-events: none;
        }
        
        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px); }
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            perspective: 1000px;
        }

        #header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        h1 {
            color: #FFD700;
            font-size: 3em;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #subtitle {
            color: #FFF;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        #score {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 40px;
            border-radius: 10px 10px 0 0;
            border: 2px solid #FFD700;
            border-bottom: none;
            color: #FFF;
            font-size: 1.6em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.5);
            display: flex;
            gap: 30px;
            align-items: center;
        }

        #gameArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .bumblebee {
            position: absolute;
            font-size: 2.5em;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="10" y="0" width="12" height="20" fill="%23964B00" rx="2"/><rect x="8" y="18" width="16" height="14" fill="%23D3D3D3" rx="4"/><line x1="16" y1="20" x2="16" y2="30" stroke="%23666" stroke-width="0.5"/><line x1="12" y1="20" x2="12" y2="30" stroke="%23666" stroke-width="0.5"/><line x1="20" y1="20" x2="20" y2="30" stroke="%23666" stroke-width="0.5"/></svg>') 16 16, crosshair;
            transition: opacity 0.2s, filter 0.3s;
            transform-origin: center center;
            z-index: 50;
            padding: 30px;
            margin: -30px;
            will-change: transform;
        }

        .splat {
            position: absolute;
            font-size: 3em;
            animation: splat 0.5s ease-out forwards;
            pointer-events: none;
            z-index: 60;
        }

        @keyframes splat {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
            }
            100% { 
                transform: scale(0.5) rotate(360deg);
                opacity: 0;
            }
        }

        #startScreen {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 200;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            width: 70%;
            max-width: 1200px;
        }

        #gameDescription {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.2em;
            line-height: 1.5;
        }

        #gameDescription h3 {
            color: #764ba2;
            margin-bottom: 15px;
            font-size: 1.6em;
        }

        #gameDescription p {
            margin-bottom: 12px;
            text-align: left;
            font-size: 1.1em;
        }

        #gameDescription .legend {
            font-style: italic;
            background: rgba(255, 215, 0, 0.2);
            padding: 10px;
            border-left: 4px solid #FFD700;
            margin-bottom: 15px;
        }

        #haiku {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 10px;
            font-style: italic;
            color: #764ba2;
            text-align: center;
            font-size: 1.1em;
            line-height: 1.8;
            border: 2px solid rgba(118, 75, 162, 0.3);
            transition: opacity 0.5s ease;
            min-height: 80px;
        }

        #haiku .line {
            display: block;
            margin: 5px 0;
        }

        #startButton {
            padding: 20px 40px;
            font-size: 1.5em;
            background: #FFD700;
            color: #333;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        #startButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }

        .hidden {
            display: none !important;
        }

        #papersBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            z-index: 1;
            pointer-events: none;
        }

        .paper-item {
            position: absolute;
            font-family: 'Courier New', monospace;
            background: rgba(0, 30, 0, 0.85);
            border: 2px solid rgba(0, 255, 0, 0.4);
            border-radius: 6px;
            padding: 20px;
            color: rgba(0, 255, 0, 0.8);
            white-space: normal;
            user-select: none;
            font-size: 20px;
            font-weight: bold;
            width: 600px;
            line-height: 1.4;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
            transform-origin: center center;
            transform-style: preserve-3d;
        }
        
        .paper-item .title {
            font-size: 24px;
            margin-bottom: 8px;
            color: rgba(100, 255, 100, 0.9);
        }
        
        .paper-item .authors {
            font-size: 16px;
            color: rgba(0, 200, 200, 0.7);
            margin-bottom: 8px;
            font-weight: normal;
            font-style: italic;
        }
        
        .paper-item .abstract {
            font-size: 14px;
            color: rgba(0, 180, 0, 0.6);
            margin: 10px 0;
            font-weight: normal;
            line-height: 1.3;
        }

        .paper-item .doi {
            display: block;
            font-size: 14px;
            color: rgba(255, 200, 0, 0.5);
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-style: normal;
            font-weight: normal;
        }

        @keyframes drift {
            0% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(30px) translateY(-20px); }
            50% { transform: translateX(-20px) translateY(10px); }
            75% { transform: translateX(10px) translateY(-30px); }
            100% { transform: translateX(0) translateY(0); }
        }

        #header, #score, #startScreen, #gameArea, #crashScreen {
            position: relative;
            z-index: 10;
        }

        #crashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0000AA;
            color: white;
            font-family: 'Courier New', monospace;
            padding: 50px;
            z-index: 9999;
            display: none;
        }

        #crashScreen h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            background: white;
            color: #0000AA;
            padding: 5px 10px;
            display: inline-block;
        }

        #crashScreen p {
            font-size: 1.1em;
            line-height: 1.6;
            margin: 10px 0;
        }

        #crashScreen .error-code {
            margin-top: 30px;
            font-size: 0.9em;
            color: #AAAAAA;
        }

        #retryButton {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 1.2em;
            background: #AAAAAA;
            color: #0000AA;
            border: 2px solid white;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }

        #retryButton:hover {
            background: white;
            color: #0000AA;
        }

        #rescueButton {
            margin-top: 15px;
            margin-left: 10px;
            padding: 15px 30px;
            font-size: 1.2em;
            background: #FF0000;
            color: white;
            border: 2px solid white;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }

        #rescueButton:hover {
            background: white;
            color: #FF0000;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="papersBackground"></div>
        <div id="header">
            <h1>🐝 Zbijanie Trzmieli 🐝</h1>
            <div id="subtitle">PNB wyświetlił ul, czas zbijać trzmiele!</div>
        </div>
        
        <div id="score" style="position: fixed !important; bottom: 0 !important; top: auto !important;">
            <div>Wynik: <span id="scoreValue">0</span></div>
            <div style="color: #FFD700;">Pojemność serwera PNB: <span id="serverCapacity">20</span> TB</div>
        </div>
        
        <div id="startScreen">
            <div id="gameDescription">
                <h3>🐝 Zbijanie Trzmieli - Instrukcja 🐝</h3>
                <p class="legend">Złe(?) trzmiele wyroiły się z uli i wtargnęły do siedziby PNB (Popularnej Niesłychanie Biblioteki). Twoim obowiązkiem jest zwalczyć je, ponieważ każdy taki trzmiel zajmuje cenną pojemność serwera PNB. Jeżeli trzmieli będzie zbyt dużo, dojdzie do krachu serwera.</p>
                <p><strong>Jak grać:</strong></p>
                <p>• Używaj kursora jako łapki na muchy do zbijania trzmieli</p>
                <p>• Trzmiele będą uciekać przed kursorem - musisz być szybki!</p>
                <p>• Z czasem pojawia się coraz więcej trzmieli</p>
                <p>• Nie pozwól, aby serwer PNB się przepełnił - max. pojemność serwera to 20 TB (trzmielobajtów)</p>
                <p>• Każdy zbity trzmiel to 10 punktów</p>
            </div>
            <button id="startButton">Rozpocznij Grę!</button>
        </div>
        
        <div id="gameArea" class="hidden"></div>
    </div>

    <div id="crashScreen">
        <h2>SERWER PNB</h2>
        <p>Serwer PNB wykonał niedozwoloną operację i zostanie zamknięty.</p>
        <p>Jeśli problem będzie się powtarzał, skontaktuj się z administratorem ula.</p>
        <br>
        <p>* Naciśnij dowolny klawisz, aby zakończyć bieżące zadanie.</p>
        <p>* Naciśnij CTRL+ALT+DEL, aby zrestartować komputer. Utracisz wszystkie niezapisane trzmiele.</p>
        <br>
        <p>Błąd: PRZEKROCZONO_POJEMNOSC_TRZMIELI</p>
        <p class="error-code">Kod błędu: 0x0BEE0042 : FATAL_BUMBLEBEE_OVERFLOW</p>
        <p class="error-code">Lokalizacja: UL://PNB/SERWER/TRZMIELE.SYS</p>
        <p class="error-code">Wywołanie stosu: SPAWN_TRZMIEL() -> CHECK_CAPACITY() -> PANIC()</p>
        <br>
        <button id="retryButton">[ SPRÓBUJ PONOWNIE ]</button>
        <button id="rescueButton">[ URATUJ SKUTECZNIE PROFIL SWOJEJ INSTYTUCJI ]</button>
    </div>

    <script>
        // Haiku collection
        const haikus = [
            {
                line1: "Cytowania mkną,",
                line2: "Serwer dyszy – kod otwarty,",
                line3: "AI trzmiele zna."
            },
            {
                line1: "Baza danych rośnie,",
                line2: "Pamięć pęka – GitHub czeka,",
                line3: "Bot odpowiada."
            },
            {
                line1: "Artykuł za artykułem,",
                line2: "CPU płonie – fork się mnoży,",
                line3: "Sieć neuronów śni."
            },
            {
                line1: "DOI jak deszcz,",
                line2: "Dysk twardy jęczy – GNU trwa,",
                line3: "Chatbot rozumie."
            },
            {
                line1: "Impact Factor lśni,",
                line2: "Kernel panikuje – MIT licencja,",
                line3: "Model się uczy."
            },
            {
                line1: "PubMed się leje,",
                line2: "RAM się kończy – pull request czeka,",
                line3: "Algorytm wie."
            },
            {
                line1: "H-index wzrasta,",
                line2: "Backup pada – commit żyje,",
                line3: "Transformer czyta."
            },
            {
                line1: "Przypisy bez końca,",
                line2: "Serwer błaga – Apache działa,",
                line3: "GPT pisze."
            },
            {
                line1: "Scopus się pieni,",
                line2: "Procesor dymi – Linux wspiera,",
                line3: "Boty analizują."
            },
            {
                line1: "Peer review trwa,",
                line2: "MySQL krzyczy – Docker łata,",
                line3: "AI recenzuje."
            },
            {
                line1: "ORCID się mnoży,",
                line2: "Klaster pada – Python ratuje,",
                line3: "Sieć przewiduje."
            },
            {
                line1: "Metadane płyną,",
                line2: "Load balancer mdleje – Git klonuje,",
                line3: "Bot klasyfikuje."
            },
            {
                line1: "CrossRef linkuje,",
                line2: "MongoDB puchnie – npm buduje,",
                line3: "AI indeksuje."
            },
            {
                line1: "Grant się rozpisuje,",
                line2: "Redis upada – źródła otwarte,",
                line3: "Model wnioskuje."
            },
            {
                line1: "Abstrakt za abstraktem,",
                line2: "Nginx się dławi – copyleft chroni,",
                line3: "Maszyna myśli."
            }
        ];

        // Haiku rotation system
        class HaikuRotator {
            constructor() {
                this.currentIndex = Math.floor(Math.random() * haikus.length);
                this.haikuElement = document.getElementById('haiku');
                this.rotationInterval = null;
                this.displayHaiku();
                this.startRotation();
            }

            displayHaiku() {
                if (!this.haikuElement) return;
                const haiku = haikus[this.currentIndex];
                this.haikuElement.innerHTML = `
                    <span class="line">${haiku.line1}</span>
                    <span class="line">${haiku.line2}</span>
                    <span class="line">${haiku.line3}</span>
                `;
                // Add fade effect
                this.haikuElement.style.opacity = '0';
                setTimeout(() => {
                    this.haikuElement.style.opacity = '1';
                }, 50);
            }

            getRandomIndex() {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * haikus.length);
                } while (newIndex === this.currentIndex && haikus.length > 1);
                return newIndex;
            }

            rotateHaiku() {
                this.currentIndex = this.getRandomIndex();
                this.displayHaiku();
            }

            startRotation() {
                this.rotationInterval = setInterval(() => {
                    this.rotateHaiku();
                }, 30000); // 30 seconds
            }

            stopRotation() {
                if (this.rotationInterval) {
                    clearInterval(this.rotationInterval);
                }
            }
        }

        class BumblebeeGame {
            constructor() {
                this.score = 0;
                this.bumblebees = [];
                this.gameArea = document.getElementById('gameArea');
                this.scoreElement = document.getElementById('scoreValue');
                this.startScreen = document.getElementById('startScreen');
                this.startButton = document.getElementById('startButton');
                this.isPlaying = false;
                this.spawnInterval = null;
                this.moveInterval = null;
                this.audioContext = null;
                this.spawnDelay = 2000;
                this.bumblebeeSpeed = 3;
                this.mouseX = 0;
                this.mouseY = 0;
                this.gameTime = 0;
                this.timeInterval = null;
                this.maxCapacity = 20; // Increased to allow more challenging gameplay
                this.currentCapacity = 15;
                this.capacityElement = null;
                this.crashScreen = null;
                this.hasCrashed = false;
                this.backgroundMusic = null;
                this.musicTransitionInterval = null;
                
                this.init();
            }

            init() {
                this.startButton.addEventListener('click', () => this.startGame());
                this.capacityElement = document.getElementById('serverCapacity');
                this.crashScreen = document.getElementById('crashScreen');
                
                // Track mouse position
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
                
                // Initialize audio context immediately for less lag
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Resume context if suspended (for Chrome autoplay policy)
                    if (this.audioContext.state === 'suspended') {
                        document.addEventListener('click', () => {
                            this.audioContext.resume();
                        }, { once: true });
                    }
                } catch (e) {
                    console.log('Audio context not available:', e);
                }
                
                // Start background music in menu at 50% volume
                this.startMenuMusic();
                
                // Removed key press handler - blue screen stays forever unless button clicked
                
                // Handle retry button
                const retryButton = document.getElementById('retryButton');
                if (retryButton) {
                    retryButton.addEventListener('click', () => {
                        this.resetToMenu();
                    });
                }
                
                // Handle rescue button
                const rescueButton = document.getElementById('rescueButton');
                if (rescueButton) {
                    rescueButton.addEventListener('click', () => {
                        window.open('https://bpp.iplweb.pl', '_blank');
                        this.resetToMenu();
                    });
                }
            }

            startGame() {
                this.startScreen.classList.add('hidden');
                this.gameArea.classList.remove('hidden');
                this.isPlaying = true;
                this.score = 0;
                this.gameTime = 0;
                this.spawnDelay = 2000;
                this.currentCapacity = this.maxCapacity;
                this.hasCrashed = false;
                this.updateScore();
                this.updateCapacity();
                
                // Ensure audio context is resumed
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                // Add click listener for miss detection (remove old one first to avoid duplicates)
                if (this.missClickHandler) {
                    this.gameArea.removeEventListener('click', this.missClickHandler);
                }
                this.missClickHandler = (e) => {
                    // Check if click was on game area background (not on a bee)
                    if (e.target === this.gameArea) {
                        this.playMissSound();
                    }
                };
                this.gameArea.addEventListener('click', this.missClickHandler);
                
                // Increase volume for gameplay with smooth transition
                if (this.backgroundMusic) {
                    this.smoothVolumeTransition(0.6, 2000); // Transition to 60% volume over 2 seconds
                }
                
                // Spawn initial bumblebees
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => this.spawnBumblebee(), i * 500);
                }
                
                // Dynamic spawning based on time - more aggressive
                const spawnLoop = () => {
                    // Calculate spawn rate based on game time - much more aggressive
                    const baseSpawnCount = Math.floor(this.gameTime / 5) + 1; // More bees every 5 seconds
                    const randomBonus = Math.floor(Math.random() * 3); // Add 0-2 random extra bees
                    const spawnCount = baseSpawnCount + randomBonus;
                    const maxSpawnCount = Math.min(spawnCount, 8); // Cap at 8 bees per spawn
                    
                    for (let i = 0; i < maxSpawnCount; i++) {
                        setTimeout(() => this.spawnBumblebee(), i * 100); // Faster spawn timing
                    }
                    
                    // Aggressively decrease spawn delay
                    if (this.spawnDelay > 300) {
                        this.spawnDelay = Math.max(300, 2000 - (this.gameTime * 50)); // Faster reduction
                    }
                    
                    // Schedule next spawn
                    this.spawnInterval = setTimeout(spawnLoop, this.spawnDelay);
                };
                
                // Start the spawn loop
                this.spawnInterval = setTimeout(spawnLoop, this.spawnDelay);
                
                // Track game time
                this.timeInterval = setInterval(() => {
                    this.gameTime++;
                }, 1000);
                
                // Move bumblebees
                this.moveInterval = setInterval(() => {
                    this.moveBumblebees();
                }, 50);
            }

            spawnBumblebee() {
                // Check capacity before spawning
                if (this.bumblebees.length >= this.maxCapacity) {
                    this.triggerCrash();
                    return;
                }
                
                const bee = document.createElement('div');
                bee.className = 'bumblebee';
                bee.innerHTML = '🐝';
                
                // Random position with 10% margin from edges
                const marginX = window.innerWidth * 0.1;
                const marginY = window.innerHeight * 0.1;
                const minX = marginX;
                const maxX = window.innerWidth - marginX - 50;
                const minY = Math.max(150, marginY); // Avoid header area and top margin
                const maxY = window.innerHeight - marginY - 50;
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                bee.style.left = x + 'px';
                bee.style.top = y + 'px';
                
                // Random movement direction (including Z-axis)
                bee.dataset.dx = (Math.random() - 0.5) * this.bumblebeeSpeed;
                bee.dataset.dy = (Math.random() - 0.5) * this.bumblebeeSpeed;
                bee.dataset.dz = (Math.random() - 0.5) * 6; // Much faster Z-axis movement
                // 70% chance to start moving toward player for scarier effect
                if (Math.random() < 0.7) {
                    bee.dataset.dz = Math.abs(parseFloat(bee.dataset.dz));
                }
                bee.dataset.z = String(Math.random() * 30); // Start farther back (0 = far, 150 = super close)
                bee.dataset.baseSpeed = this.bumblebeeSpeed;
                bee.dataset.fleeSpeed = 0;
                
                // Set initial size based on Z position
                this.updateBeeSize(bee, 50);
                
                bee.addEventListener('click', (e) => this.swatBumblebee(e, bee));
                
                this.gameArea.appendChild(bee);
                this.bumblebees.push(bee);
                this.updateCapacity();
            }

            moveBumblebees() {
                this.bumblebees.forEach(bee => {
                    if (!bee.parentNode) return;
                    
                    let x = parseFloat(bee.style.left);
                    let y = parseFloat(bee.style.top);
                    let z = parseFloat(bee.dataset.z);
                    let dx = parseFloat(bee.dataset.dx);
                    let dy = parseFloat(bee.dataset.dy);
                    let dz = parseFloat(bee.dataset.dz);
                    
                    // Calculate distance to mouse (adjusted for larger hitbox)
                    const beeX = x + 25 + 30; // Center of bee + padding
                    const beeY = y + 25 + 30;
                    const distToMouse = Math.sqrt(Math.pow(this.mouseX - beeX, 2) + Math.pow(this.mouseY - beeY, 2));
                    
                    // Flee from mouse if too close (reduced radius to make catching easier)
                    const fleeRadius = 100;
                    const panicRadius = 50;
                    
                    if (distToMouse < fleeRadius) {
                        // Calculate flee direction (away from mouse)
                        const fleeX = beeX - this.mouseX;
                        const fleeY = beeY - this.mouseY;
                        const fleeMagnitude = Math.sqrt(fleeX * fleeX + fleeY * fleeY);
                        
                        if (fleeMagnitude > 0) {
                            // Normalize and apply flee force
                            const normalizedFleeX = fleeX / fleeMagnitude;
                            const normalizedFleeY = fleeY / fleeMagnitude;
                            
                            // Stronger flee force when mouse is closer
                            const fleePower = distToMouse < panicRadius ? 8 : 4;
                            const fleeInfluence = (1 - distToMouse / fleeRadius) * fleePower;
                            
                            // Update direction with flee influence
                            dx = dx * 0.7 + normalizedFleeX * fleeInfluence;
                            dy = dy * 0.7 + normalizedFleeY * fleeInfluence;
                            
                            // Increase speed when fleeing
                            const speedMultiplier = distToMouse < panicRadius ? 3 : 2;
                            const maxSpeed = parseFloat(bee.dataset.baseSpeed) * speedMultiplier;
                            
                            // Limit maximum speed
                            const currentSpeed = Math.sqrt(dx * dx + dy * dy);
                            if (currentSpeed > maxSpeed) {
                                dx = (dx / currentSpeed) * maxSpeed;
                                dy = (dy / currentSpeed) * maxSpeed;
                            }
                            
                            bee.dataset.dx = dx;
                            bee.dataset.dy = dy;
                        }
                    } else {
                        // Gradually return to normal speed when safe
                        const normalSpeed = parseFloat(bee.dataset.baseSpeed);
                        const currentSpeed = Math.sqrt(dx * dx + dy * dy);
                        
                        if (currentSpeed > normalSpeed) {
                            dx *= 0.95;
                            dy *= 0.95;
                            bee.dataset.dx = dx;
                            bee.dataset.dy = dy;
                        }
                    }
                    
                    // Update position including Z-axis
                    x += dx;
                    y += dy;
                    z += dz;
                    
                    // When bee comes super close, make it zoom back dramatically
                    if (z >= 150) {
                        dz = -(Math.random() * 8 + 4); // Fast zoom back
                        bee.dataset.dz = dz;
                    } else if (z <= 0) {
                        dz = Math.random() * 6 + 2; // Zoom forward aggressively
                        bee.dataset.dz = dz;
                    }
                    
                    // 5% chance to suddenly accelerate toward player (jump scare)
                    if (Math.random() < 0.05 && z < 100) {
                        dz = Math.abs(dz) * 3;
                        bee.dataset.dz = dz;
                    }
                    
                    z = Math.max(0, Math.min(150, z));
                    bee.dataset.z = z;
                    
                    // Update size based on Z position
                    this.updateBeeSize(bee, z);
                    
                    // Bounce off walls
                    if (x <= 0 || x >= window.innerWidth - 50) {
                        dx = -dx;
                        bee.dataset.dx = dx;
                    }
                    if (y <= 150 || y >= window.innerHeight - 50) {
                        dy = -dy;
                        bee.dataset.dy = dy;
                    }
                    
                    // Random direction change including Z-axis (less frequent when fleeing)
                    if (distToMouse >= fleeRadius && Math.random() < 0.01) {
                        bee.dataset.dx = (Math.random() - 0.5) * this.bumblebeeSpeed;
                        bee.dataset.dy = (Math.random() - 0.5) * this.bumblebeeSpeed;
                        bee.dataset.dz = (Math.random() - 0.5) * 8; // Much more aggressive Z changes
                        // 60% chance to zoom toward player
                        if (Math.random() < 0.6) {
                            bee.dataset.dz = Math.abs(parseFloat(bee.dataset.dz));
                        }
                    }
                    
                    bee.style.left = x + 'px';
                    bee.style.top = y + 'px';
                });
            }

            swatBumblebee(e, bee) {
                e.stopPropagation();
                
                // Play sound effect
                this.playSwatSound();
                
                // Create splat effect
                const splat = document.createElement('div');
                splat.className = 'splat';
                splat.innerHTML = '💥';
                splat.style.left = bee.style.left;
                splat.style.top = bee.style.top;
                this.gameArea.appendChild(splat);
                
                // Remove splat after animation
                setTimeout(() => splat.remove(), 500);
                
                // Remove bumblebee
                const index = this.bumblebees.indexOf(bee);
                if (index > -1) {
                    this.bumblebees.splice(index, 1);
                }
                bee.remove();
                
                // Update score and capacity
                this.score += 10;
                this.updateScore();
                this.updateCapacity();
                
                // Increase difficulty
                if (this.score % 50 === 0) {
                    this.bumblebeeSpeed += 0.5;
                }
            }

            playSwatSound() {
                if (!this.audioContext) return;
                
                // Use immediate timing for less lag
                const now = this.audioContext.currentTime;
                
                // Random pitch variation for each hit
                const basePitch = 600;
                const pitchVariation = 0.5 + Math.random(); // 0.5x to 1.5x pitch
                const randomPitch = basePitch * pitchVariation;
                
                // Create multiple oscillators for richer sound
                const oscillator1 = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator1.connect(filter);
                oscillator2.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Set filter for warmer sound
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, now);
                
                // Different waveforms for texture
                oscillator1.type = 'square';
                oscillator2.type = 'sawtooth';
                
                // Random pitch swat sound
                oscillator1.frequency.setValueAtTime(randomPitch, now);
                oscillator1.frequency.exponentialRampToValueAtTime(randomPitch * 0.25, now + 0.08);
                
                oscillator2.frequency.setValueAtTime(randomPitch * 1.5, now);
                oscillator2.frequency.exponentialRampToValueAtTime(randomPitch * 0.5, now + 0.06);
                
                // Quick fade with random volume
                const volume = 0.15 + Math.random() * 0.1; // 0.15 to 0.25
                gainNode.gain.setValueAtTime(volume, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                
                oscillator1.start(now);
                oscillator1.stop(now + 0.08);
                oscillator2.start(now);
                oscillator2.stop(now + 0.06);
            }
            
            playMissSound() {
                if (!this.audioContext) return;
                
                const now = this.audioContext.currentTime;
                
                // Create a "whoosh" miss sound
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Use noise-like sound
                oscillator.type = 'triangle';
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
                
                // Quick sweep for "whoosh" effect
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                
                // Soft volume
                gainNode.gain.setValueAtTime(0.08, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }

            updateScore() {
                this.scoreElement.textContent = this.score;
            }
            
            updateBeeSize(bee, z) {
                // Z ranges from 0 (far) to 150 (SUPER close)
                // Size ranges from 0.1x to 5x for EXTREME zoom effect
                let scale;
                if (z > 100) {
                    // Super aggressive scaling when very close
                    scale = 2.5 + ((z - 100) / 50) * 2.5; // 2.5x to 5x
                } else {
                    scale = 0.1 + (z / 100) * 2.4; // 0.1x to 2.5x
                }
                
                // Add slight rotation for more dynamic movement
                const rotation = Math.sin(Date.now() * 0.001 + parseFloat(bee.dataset.z)) * 5;
                bee.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
                
                // Adjust opacity (very close bees are fully opaque and scary)
                const opacity = z > 100 ? 1 : 0.3 + (z / 100) * 0.7;
                bee.style.opacity = opacity;
                
                // Adjust z-index so closer bees appear on top
                bee.style.zIndex = Math.floor(50 + z);
                
                // Extreme blur for distant bees, no blur when close
                const blur = z < 20 ? (20 - z) / 10 : 0;
                bee.style.filter = blur > 0 ? `blur(${blur * 3}px)` : 'none';
                
                // Add red glow to super close bees for scarier effect
                if (z > 120) {
                    bee.style.filter = 'drop-shadow(0 0 20px rgba(255, 0, 0, 0.5))';
                }
            }
            
            resetToMenu() {
                // Hide crash screen
                this.crashScreen.style.display = 'none';
                
                // Clear game area
                this.gameArea.innerHTML = '';
                this.bumblebees = [];
                
                // Reset game state
                this.isPlaying = false;
                this.hasCrashed = false;
                this.score = 0;
                this.gameTime = 0;
                this.currentCapacity = this.maxCapacity;
                
                // Clear any running intervals
                clearInterval(this.spawnInterval);
                clearInterval(this.moveInterval);
                clearInterval(this.timeInterval);
                clearTimeout(this.spawnInterval);
                
                // Reset music to menu settings with smooth transition
                if (this.backgroundMusic) {
                    this.smoothVolumeTransition(0.3, 2000); // Transition to menu volume over 2 seconds
                    // Don't restart the music, let it continue playing
                }
                
                // Show start screen
                this.startScreen.classList.remove('hidden');
                this.gameArea.classList.add('hidden');
                
                // Update displays
                this.updateScore();
                this.updateCapacity();
            }

            startMenuMusic() {
                if (!this.backgroundMusic) {
                    this.backgroundMusic = new Audio('https://ia801607.us.archive.org/34/items/FlightOfTheBumblebee/flight_of_the_bumblebee_2.mp3');
                    this.backgroundMusic.loop = true;
                    this.backgroundMusic.volume = 0.3; // Start at 30% volume for menu
                    
                    // Try to play immediately
                    const playPromise = this.backgroundMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(err => {
                            console.log('Autoplay prevented, will play on first user interaction:', err);
                            // Try again on first user interaction
                            const playOnInteraction = () => {
                                this.backgroundMusic.play().catch(() => {});
                                document.removeEventListener('click', playOnInteraction);
                                document.removeEventListener('keydown', playOnInteraction);
                            };
                            document.addEventListener('click', playOnInteraction);
                            document.addEventListener('keydown', playOnInteraction);
                        });
                    }
                } else {
                    // If music exists but is paused, try to play it
                    if (this.backgroundMusic.paused) {
                        this.backgroundMusic.play().catch(() => {});
                    }
                    this.backgroundMusic.volume = 0.3; // 30% volume for menu
                    this.backgroundMusic.playbackRate = 1.0; // Normal speed
                }
            }
            
            smoothVolumeTransition(targetVolume, duration) {
                if (!this.backgroundMusic) return;
                
                const startVolume = this.backgroundMusic.volume;
                const startTime = Date.now();
                
                // Clear any existing transition
                if (this.volumeTransitionInterval) {
                    clearInterval(this.volumeTransitionInterval);
                }
                
                this.volumeTransitionInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use easing function for smoother transition
                    const easeProgress = this.easeInOutCubic(progress);
                    
                    // Update volume smoothly
                    this.backgroundMusic.volume = startVolume + (targetVolume - startVolume) * easeProgress;
                    
                    // Stop when complete
                    if (progress >= 1) {
                        clearInterval(this.volumeTransitionInterval);
                        this.volumeTransitionInterval = null;
                    }
                }, 50); // Update every 50ms
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            updateCapacity() {
                this.currentCapacity = Math.max(0, this.maxCapacity - this.bumblebees.length);
                this.capacityElement.textContent = this.currentCapacity;
                
                // Change color based on capacity
                if (this.currentCapacity <= 3) {
                    this.capacityElement.style.color = '#FF0000';
                } else if (this.currentCapacity <= 7) {
                    this.capacityElement.style.color = '#FFA500';
                } else {
                    this.capacityElement.style.color = '#FFD700';
                }
            }

            triggerCrash() {
                if (this.hasCrashed) return;
                
                this.hasCrashed = true;
                this.isPlaying = false;
                
                // Stop all intervals
                clearInterval(this.spawnInterval);
                clearInterval(this.moveInterval);
                clearInterval(this.timeInterval);
                
                // Lower volume for game over effect
                if (this.backgroundMusic) {
                    // Ensure music keeps playing during transition
                    if (this.backgroundMusic.paused) {
                        this.backgroundMusic.play().catch(() => {});
                    }
                    this.smoothVolumeTransition(0.3, 2000); // Lower volume to 30% over 2 seconds
                }
                
                // Show crash screen
                this.crashScreen.style.display = 'block';
                
                // Play crash sound
                if (this.audioContext) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                }
            }
        }

        // Function to create a single paper element
        function createPaperElement(paper, isFromAPI = false) {
            const paperDiv = document.createElement('div');
            paperDiv.className = 'paper-item';
            
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            const rotation = Math.random() * 90 - 45;
            const rotationX = Math.random() * 40 - 20;
            const rotationY = Math.random() * 40 - 20;
            const scale = 0.7 + Math.random() * 0.5;
            
            paperDiv.style.left = x + 'px';
            paperDiv.style.top = y + 'px';
            paperDiv.style.cssText += `transform: rotate(${rotation}deg) rotateX(${rotationX}deg) rotateY(${rotationY}deg) scale(${scale}) !important;`;
            paperDiv.style.opacity = 0;
            
            if (isFromAPI) {
                const title = paper.title ? paper.title[0] : 'Untitled';
                const doi = paper.DOI || 'No DOI';
                
                // Filter out non-English characters
                if (!/^[\x00-\x7F]*$/.test(title)) {
                    return null;
                }
                
                const authors = paper.author ? 
                    paper.author.slice(0, 3).map(a => `${a.given || ''} ${a.family || ''}`).join(', ') + 
                    (paper.author.length > 3 ? ' et al.' : '') : 
                    'Anonymous';
                
                const abstract = paper.abstract ? 
                    paper.abstract.substring(0, 150) + '...' : 
                    'No abstract available for this publication.';
                
                paperDiv.innerHTML = `
                    <div class="title">${title}</div>
                    <div class="authors">${authors}</div>
                    <div class="abstract">${abstract}</div>
                    <div class="doi">DOI: ${doi}</div>
                `;
            } else {
                // Generate funny fake authors
                const funnyAuthors = [
                    'Dr. Buzz Beeson', 'Prof. Honey Combsworth', 'Bumble McFlightface', 'Queen B. Pollinater',
                    'Stinger McMuffin', 'Dr. Waggle Dance', 'Prof. Nectar Sipper', 'Pollen Pantsworth',
                    'Dr. Fuzzy Thorax', 'Wing Flapperton III', 'Prof. Hive Mind', 'Antennae Wiggler',
                    'Dr. Striped Abdomen', 'Compound Eyes McGee', 'Prof. Hexagon Builder'
                ];
                
                // Randomly select 2-4 authors
                const authorCount = 2 + Math.floor(Math.random() * 3);
                const selectedAuthors = [];
                const usedIndices = new Set();
                while (selectedAuthors.length < authorCount) {
                    const idx = Math.floor(Math.random() * funnyAuthors.length);
                    if (!usedIndices.has(idx)) {
                        usedIndices.add(idx);
                        selectedAuthors.push(funnyAuthors[idx]);
                    }
                }
                
                // Generate funny fake abstracts
                const funnyAbstracts = [
                    'We demonstrate that bees debugging JavaScript run 47% faster when servers are painted with yellow stripes...',
                    'Our groundbreaking research proves that bumblebees prefer PostgreSQL over MySQL by a factor of bzzzz...',
                    'This paper presents conclusive evidence that server rooms perform better with artificial flowers installed...',
                    'We discovered that playing "Flight of the Bumblebee" increases database query speed by 420%...',
                    'Our study shows that hexagonal server racks improve cooling efficiency and make bees 200% happier...',
                    'We prove mathematically that Polish servers crash less frequently when protected by digital bumblebees...',
                    'This research demonstrates that API endpoints work better when named after different types of honey...',
                    'Our findings indicate that Git commits are 69% more likely to succeed when prefixed with "bzzzz"...',
                    'We show that servers running on pollen-based energy are both sustainable and delicious...',
                    'This paper reveals that quantum entanglement between bees and servers creates infinite bandwidth...',
                    'Our experiments confirm that machine learning models trained on bee dances achieve 99.9% accuracy...',
                    'We demonstrate that blockchain technology was actually invented by bees 65 million years ago...',
                    'This study proves that cloud computing works better when actual clouds contain at least 10 bees...',
                    'Our research shows that debugging is 300% more effective when programmers wear bee costumes...',
                    'We discovered that neural networks modeled after bee brains can predict tomorrow\'s memes...'
                ];
                
                paperDiv.innerHTML = `
                    <div class="title">${paper.title}</div>
                    <div class="authors">${selectedAuthors.join(', ')} et al.</div>
                    <div class="abstract">${funnyAbstracts[Math.floor(Math.random() * funnyAbstracts.length)]}</div>
                    <div class="doi">DOI: ${paper.doi}</div>
                `;
            }
            
            // Store initial position for escape behavior
            paperDiv.dataset.baseX = x;
            paperDiv.dataset.baseY = y;
            paperDiv.dataset.currentX = x;
            paperDiv.dataset.currentY = y;
            
            // Fade in animation
            setTimeout(() => {
                paperDiv.style.opacity = 0.7 + Math.random() * 0.3;
            }, 100);
            
            return paperDiv;
        }
        
        // Function to fetch and display scientific papers
        async function loadScientificPapers(isRefresh = false) {
            const papersBackground = document.getElementById('papersBackground');
            const maxPapers = 8 + Math.floor(Math.random() * 3); // 8-10 papers
            let loadedPapers = 0;
            
            // If refreshing, fade out and remove old papers first
            if (isRefresh) {
                const oldPapers = document.querySelectorAll('.paper-item');
                oldPapers.forEach((paper, index) => {
                    setTimeout(() => {
                        paper.style.opacity = '0';
                        setTimeout(() => paper.remove(), 500);
                    }, index * 50);
                });
                // Wait for all papers to be removed before adding new ones
                await new Promise(resolve => setTimeout(resolve, oldPapers.length * 50 + 600));
            }
            
            // Funny fake papers
            const fakePapers = [
                { title: 'Why Bees Make Better Database Administrators Than Humans', doi: '10.BZZZ/honey.2024.001' },
                { title: 'The Waggle Dance Protocol: A New Approach to Network Communication', doi: '10.BZZZ/dance.2024.002' },
                { title: 'Hexagonal Architecture: Why Six-Sided Servers Are Superior', doi: '10.BZZZ/hex.2024.003' },
                { title: 'Pollen-Based Encryption: Nature\'s Answer to Cybersecurity', doi: '10.BZZZ/pollen.2024.004' },
                { title: 'Queen Bee Leadership Patterns in Agile Development', doi: '10.BZZZ/queen.2024.005' },
                { title: 'The Hive Mind Approach to Distributed Computing', doi: '10.BZZZ/hive.2024.006' },
                { title: 'Nectar-Driven Development: Sweet Solutions for Bitter Problems', doi: '10.BZZZ/nectar.2024.007' },
                { title: 'Stinger Security: Defending Polish Servers from Digital Wasps', doi: '10.BZZZ/sting.2024.008' },
                { title: 'Buzz-Driven Testing: How Vibrations Improve Code Quality', doi: '10.BZZZ/buzz.2024.009' },
                { title: 'The Flower-Server Interface: Optimizing Pollination Protocols', doi: '10.BZZZ/flower.2024.010' },
                { title: 'Swarm Intelligence vs Artificial Intelligence: Bees Win Every Time', doi: '10.BZZZ/swarm.2024.011' },
                { title: 'Honeycomb Data Structures: Maximum Storage, Minimum Waste', doi: '10.BZZZ/comb.2024.012' },
                { title: 'Wing-Beat Frequency Analysis for Server Load Balancing', doi: '10.BZZZ/wing.2024.013' },
                { title: 'The Bumble Algorithm: Chaotic Flying Patterns in Search Optimization', doi: '10.BZZZ/bumble.2024.014' },
                { title: 'Royal Jelly as a Performance Enhancer for Legacy Systems', doi: '10.BZZZ/jelly.2024.015' },
                { title: 'Antenna-Based Wireless Communication: Lessons from Insects', doi: '10.BZZZ/antenna.2024.016' },
                { title: 'The Economics of Digital Pollination in Cloud Environments', doi: '10.BZZZ/cloud.2024.017' },
                { title: 'Compound Eyes: Multi-Perspective Debugging Techniques', doi: '10.BZZZ/eyes.2024.018' },
                { title: 'Fuzzy Logic: Why Bumblebees Outperform Boolean Operations', doi: '10.BZZZ/fuzzy.2024.019' },
                { title: 'The Flight Path Algorithm: Non-Linear Solutions to Linear Problems', doi: '10.BZZZ/flight.2024.020' }
            ];
            
            // Create a 50/50 mix of real and fake papers
            const papersToDisplay = [];
            const halfPapers = Math.floor(maxPapers / 2);
            
            // Try to fetch real papers from API
            try {
                const response = await fetch(`https://api.crossref.org/works?query=digital+library&rows=${halfPapers}`);
                const data = await response.json();
                
                if (data.message && data.message.items) {
                    // Add real papers (up to half)
                    data.message.items.slice(0, halfPapers).forEach(paper => {
                        papersToDisplay.push({ paper, isFromAPI: true });
                    });
                }
            } catch (error) {
                console.log('Could not load real papers:', error);
            }
            
            // Add fake papers to reach 50/50 mix
            const remainingSlots = maxPapers - papersToDisplay.length;
            const shuffledFakes = [...fakePapers].sort(() => Math.random() - 0.5);
            shuffledFakes.slice(0, remainingSlots).forEach(paper => {
                papersToDisplay.push({ paper, isFromAPI: false });
            });
            
            // Shuffle all papers together for random distribution
            const shuffledPapers = papersToDisplay.sort(() => Math.random() - 0.5);
            
            // Display all papers with delays
            shuffledPapers.forEach((item, index) => {
                setTimeout(() => {
                    const paperElement = createPaperElement(item.paper, item.isFromAPI);
                    if (paperElement) {
                        papersBackground.appendChild(paperElement);
                        loadedPapers++;
                    }
                }, index * 200);
            });
            
            // If no papers were loaded, show only fake papers as fallback
            if (papersToDisplay.length === 0) {
                console.log('Loading fallback papers only');
                shuffledFakes.slice(0, maxPapers).forEach((paper, index) => {
                    setTimeout(() => {
                        const paperElement = createPaperElement(paper, false);
                        if (paperElement) {
                            papersBackground.appendChild(paperElement);
                        }
                    }, index * 200);
                });
            }
        }
        
        // Function to make papers escape from mouse
        function animatePapers() {
            const papers = document.querySelectorAll('.paper-item');
            let mouseX = 0;
            let mouseY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            setInterval(() => {
                papers.forEach(paper => {
                    if (!paper.dataset.baseX) return;
                    
                    const baseX = parseFloat(paper.dataset.baseX);
                    const baseY = parseFloat(paper.dataset.baseY);
                    let currentX = parseFloat(paper.dataset.currentX);
                    let currentY = parseFloat(paper.dataset.currentY);
                    
                    // Calculate distance to mouse
                    const dx = currentX + 300 - mouseX; // Center of paper
                    const dy = currentY + 100 - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Escape from mouse if too close
                    if (distance < 300) {
                        const escapeForce = (300 - distance) / 300;
                        const escapeX = (dx / distance) * escapeForce * 100;
                        const escapeY = (dy / distance) * escapeForce * 100;
                        
                        currentX = baseX + escapeX;
                        currentY = baseY + escapeY;
                    } else {
                        // Slowly return to base position
                        currentX += (baseX - currentX) * 0.05;
                        currentY += (baseY - currentY) * 0.05;
                    }
                    
                    paper.dataset.currentX = currentX;
                    paper.dataset.currentY = currentY;
                    paper.style.left = currentX + 'px';
                    paper.style.top = currentY + 'px';
                });
            }, 50);
        }
        
        // Start the game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const game = new BumblebeeGame();
            
            // Load scientific papers in background
            loadScientificPapers();
            
            // Start paper escape animation after papers load
            setTimeout(animatePapers, 2000);
            
            // Periodically refresh papers every 30-60 seconds
            setInterval(() => {
                const refreshDelay = 30000 + Math.random() * 30000; // 30-60 seconds
                setTimeout(() => {
                    loadScientificPapers(true); // Refresh papers
                }, refreshDelay);
            }, 45000); // Check every 45 seconds on average
        });
    </script>
</body>
</html>
